"use strict";

var _utils = require("../utils");
var _utils2 = require("./utils");
var focusable = function focusable(props) {
  if (!props) {
    props = {};
  }
  var nodeObject = {
    id: 'child',
    tabindex: 0
  };
  Object.keys(props).forEach(function (key) {
    nodeObject[key] = props[key];
  });
  return (0, _utils2.node)(nodeObject);
};
var scenarios = {
  tabIndexMinusOne: (0, _utils2.node)({
    id: 'child',
    tabindex: -1
  }),
  focusable: focusable(),
  button: focusable({
    tag: 'button'
  }),
  buttonWithDisabled: focusable({
    tag: 'button',
    valueOnlyAttribute: 'disabled'
  }),
  link: focusable({
    tag: 'a',
    href: 'www.enactjs.com'
  }),
  input: focusable({
    tag: 'input'
  })
};
describe('utils', function () {
  describe('#getIntersectionRect', function () {
    test('should return the intersection rect between two given rects', function () {
      var rect1 = {
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            left: 0,
            top: 0,
            width: 100,
            height: 100
          };
        }
      };
      var rect2 = {
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            left: 50,
            top: 50,
            width: 100,
            height: 100
          };
        }
      };
      var expected = {
        left: 50,
        top: 50,
        width: 50,
        height: 50,
        right: 100,
        bottom: 100,
        center: {
          x: 75,
          y: 75,
          left: 75,
          right: 75,
          top: 75,
          bottom: 75
        },
        element: rect2
      };
      var actual = (0, _utils.getIntersectionRect)(rect1, rect2);
      expect(actual).toEqual(expected);
    });
  });
  describe('#getRect', function () {
    test('should return the rect value calculated based on the given element', function () {
      var element = {
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            left: 10,
            top: 20,
            width: 100,
            height: 200
          };
        }
      };
      var expected = {
        left: 10,
        top: 20,
        width: 100,
        height: 200,
        right: 110,
        bottom: 220,
        center: {
          x: 60,
          y: 120,
          left: 60,
          right: 60,
          top: 120,
          bottom: 120
        },
        element: element
      };
      var actual = (0, _utils.getRect)(element);
      expect(actual).toEqual(expected);
    });
  });
  describe('#getPointRect', function () {
    test('should return an rect value calculated based on given position', function () {
      var expected = {
        left: 10,
        top: 20,
        width: 0,
        height: 0,
        right: 10,
        bottom: 20,
        center: {
          x: 10,
          y: 20,
          left: 10,
          right: 10,
          top: 20,
          bottom: 20
        }
      };
      var actual = (0, _utils.getPointRect)({
        x: 10,
        y: 20
      });
      expect(actual).toEqual(expected);
    });
  });
  describe('#getContainerRect', function () {
    test('should return an viewPort rect value when container is document', function () {
      var innerWidth = window.innerWidth;
      var innerHeight = window.innerHeight;
      var actual = (0, _utils.getContainerRect)('spotlightRootDecorator');
      var expected = {
        left: 0,
        top: 0,
        width: innerWidth,
        height: innerHeight,
        right: innerWidth,
        bottom: innerHeight,
        center: {
          x: innerWidth / 2,
          y: innerHeight / 2,
          left: innerWidth / 2,
          right: innerWidth / 2,
          top: innerHeight / 2,
          bottom: innerHeight / 2
        }
      };
      expect(actual).toEqual(expected);
    });
  });
  describe('#isStandardFocusable', function () {
    beforeEach(function () {
      global.Element.prototype.getBoundingClientRect = jest.fn(function () {
        return {
          height: 100,
          width: 100
        };
      });
    });
    test('should return false if tabIndex < 0', (0, _utils2.testScenario)(scenarios.tabIndexMinusOne, function (root) {
      var child = root.querySelector('#child');
      var expected = false;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
    test('should return false if hidden', (0, _utils2.testScenario)(scenarios.focusable, function (root) {
      var child = root.querySelector('#child');
      child.getBoundingClientRect = jest.fn(function () {
        return {
          height: 0,
          width: 0
        };
      });
      var expected = false;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
    test('should return true if button tag', (0, _utils2.testScenario)(scenarios.button, function (root) {
      var child = root.querySelector('#child');
      var expected = true;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
    test('should return false if button tag with disabled', (0, _utils2.testScenario)(scenarios.buttonWithDisabled, function (root) {
      var child = root.querySelector('#child');
      var expected = false;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
    test('should return true if A tag with href', (0, _utils2.testScenario)(scenarios.link, function (root) {
      var child = root.querySelector('#child');
      var expected = true;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
    test('should return true if input tag', (0, _utils2.testScenario)(scenarios.input, function (root) {
      var child = root.querySelector('#child');
      var expected = true;
      var actual = (0, _utils.isStandardFocusable)(child);
      expect(actual).toEqual(expected);
    }));
  });
});