"use strict";

require("@testing-library/jest-dom");
var _react = require("@testing-library/react");
var _Scroller = _interopRequireWildcard(require("../Scroller"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
describe('Scroller', function () {
  var contents;
  beforeEach(function () {
    contents = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: ["Lorem ipsum dolor sit amet, consectetur adipiscing elit.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Aenean id blandit nunc. Donec lacinia nisi vitae mi dictum, eget pulvinar nunc tincidunt. Integer vehicula tempus rutrum. Sed efficitur neque in arcu dignissim cursus."]
    });
  });
  afterEach(function () {
    contents = null;
  });
  describe('Scrollbar visibility', function () {
    test('should render both horizontal and vertical scrollbars when \'horizontalScrollbar\' and \'verticalScrollbar\' are "visible"', function () {
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "visible",
        verticalScrollbar: "visible",
        children: contents
      }));
      var upScrollbarButton = _react.screen.getByLabelText('scroll up');
      var downScrollbarButton = _react.screen.getByLabelText('scroll down');
      var leftScrollbarButton = _react.screen.getByLabelText('scroll left');
      var rightScrollbarButton = _react.screen.getByLabelText('scroll right');
      expect(upScrollbarButton).toBeInTheDocument();
      expect(downScrollbarButton).toBeInTheDocument();
      expect(leftScrollbarButton).toBeInTheDocument();
      expect(rightScrollbarButton).toBeInTheDocument();
    });
    test('should render only vertical scrollbar when \'verticalScrollbar\' is "visible" and \'horizontalScrollbar\' is "hidden"', function () {
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "hidden",
        verticalScrollbar: "visible",
        children: contents
      }));
      var upScrollbarButton = _react.screen.getByLabelText('scroll up');
      var downScrollbarButton = _react.screen.getByLabelText('scroll down');
      var leftScrollbarButton = _react.screen.queryByLabelText('scroll left');
      var rightScrollbarButton = _react.screen.queryByLabelText('scroll right');
      expect(upScrollbarButton).toBeInTheDocument();
      expect(downScrollbarButton).toBeInTheDocument();
      expect(leftScrollbarButton).toBeNull();
      expect(rightScrollbarButton).toBeNull();
    });
    test('should not render any scrollbar when when \'horizontalScrollbar\' and \'verticalScrollbar\' are "hidden"', function () {
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "hidden",
        verticalScrollbar: "hidden",
        children: contents
      }));
      var upScrollbarButton = _react.screen.queryByLabelText('scroll up');
      var downScrollbarButton = _react.screen.queryByLabelText('scroll down');
      var leftScrollbarButton = _react.screen.queryByLabelText('scroll left');
      var rightScrollbarButton = _react.screen.queryByLabelText('scroll right');
      expect(upScrollbarButton).toBeNull();
      expect(downScrollbarButton).toBeNull();
      expect(leftScrollbarButton).toBeNull();
      expect(rightScrollbarButton).toBeNull();
    });
  });
  describe('Scrollbar accessibility', function () {
    test('should set "aria-label" to previous scroll button in the horizontal scroll bar', function () {
      var label = 'custom button aria label';
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "visible",
        scrollLeftAriaLabel: label,
        verticalScrollbar: "visible",
        children: contents
      }));
      var previousScrollbarButtonLabel = _react.screen.getByLabelText(label);
      var previousScrollbarButton = _react.screen.getByLabelText(label).parentElement;
      expect(previousScrollbarButtonLabel).toBeInTheDocument();
      expect(previousScrollbarButton).toHaveClass('horizontal');
    });
    test('should set "aria-label" to next scroll button in the horizontal scroll bar', function () {
      var label = 'custom button aria label';
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "visible",
        scrollRightAriaLabel: label,
        verticalScrollbar: "visible",
        children: contents
      }));
      var nextScrollbarButtonLabel = _react.screen.getByLabelText(label);
      var nextScrollbarButton = _react.screen.getByLabelText(label).parentElement;
      expect(nextScrollbarButtonLabel).toBeInTheDocument();
      expect(nextScrollbarButton).toHaveClass('horizontal');
    });
    test('should set "aria-label" to previous scroll button in the vertical scroll bar', function () {
      var label = 'custom button aria label';
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "visible",
        scrollUpAriaLabel: label,
        verticalScrollbar: "visible",
        children: contents
      }));
      var previousScrollbarButtonLabel = _react.screen.getByLabelText(label);
      var previousScrollbarButton = _react.screen.getByLabelText(label).parentElement;
      expect(previousScrollbarButtonLabel).toBeInTheDocument();
      expect(previousScrollbarButton).toHaveClass('vertical');
    });
    test('should set "aria-label" to next scroll button in the vertical scroll bar', function () {
      var label = 'custom button aria label';
      (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller["default"], {
        horizontalScrollbar: "visible",
        verticalScrollbar: "visible",
        scrollDownAriaLabel: label,
        children: contents
      }));
      var nextScrollbarButtonLabel = _react.screen.getByLabelText(label);
      var nextScrollbarButton = _react.screen.getByLabelText(label).parentElement;
      expect(nextScrollbarButtonLabel).toBeInTheDocument();
      expect(nextScrollbarButton).toHaveClass('vertical');
    });
  });
  describe('ScrollerBase API', function () {
    test('should call onUpdate when Scroller updates', /*#__PURE__*/_asyncToGenerator(function* () {
      var handleUpdate = jest.fn();
      var _render = (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller.ScrollerBase, {
          onUpdate: handleUpdate,
          children: contents
        })),
        rerender = _render.rerender;
      rerender( /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller.ScrollerBase, {
        onUpdate: handleUpdate,
        children: ''
      }));
      yield (0, _react.waitFor)(function () {
        return expect(handleUpdate).toHaveBeenCalled();
      });
    }));
  });
});