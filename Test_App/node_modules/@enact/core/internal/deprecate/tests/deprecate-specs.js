"use strict";

var _deprecate = _interopRequireDefault(require("../deprecate"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
describe('deprecate', function () {
  var Thing = function Thing() {
    return 'return';
  };
  var config = {
    name: 'DeprecatedThing',
    message: 'No more information',
    since: '0.0.0',
    until: '0.0.1',
    replacedBy: 'ValidThing',
    alwaysWarn: true
  };
  var expectedMessage = 'DEPRECATED: DeprecatedThing since 0.0.0. Will be removed in 0.0.1. Replaced by ValidThing. No more information.';
  var consoleWarnMock = null;
  beforeEach(function () {
    consoleWarnMock = jest.spyOn(console, 'warn').mockImplementation();
  });
  afterEach(function () {
    consoleWarnMock.mockRestore();
  });
  test('should call console.warn with a warning message for deprecated function', function () {
    var WarningThing = (0, _deprecate["default"])(Thing, config);
    var expected = Thing();
    var actual = WarningThing();
    expect(actual).toBe(expected);
    expect(consoleWarnMock).toHaveBeenCalledWith(expect.stringContaining(expectedMessage));
  });
  test('should call console.warn with a warning message for stand-alone usage', function () {
    var expected = config;
    var actual = (0, _deprecate["default"])(config);
    expect(actual).toBe(expected);
    expect(consoleWarnMock).toHaveBeenCalledWith(expect.stringContaining(expectedMessage));
  });
});