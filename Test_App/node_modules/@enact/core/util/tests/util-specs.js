"use strict";

var _react = require("react");
var _util = require("../util");
describe('util', function () {
  describe('cap', function () {
    test('should return a capitalized string', function () {
      expect((0, _util.cap)('abc')).toBe('Abc');
    });
  });
  describe('clamp', function () {
    test('should return a value between a min value and a max value', function () {
      expect((0, _util.clamp)(10, 20, 15)).toBe(15);
      expect((0, _util.clamp)(10, 20, 0)).toBe(10);
      expect((0, _util.clamp)(10, 20, 30)).toBe(20);
      expect((0, _util.clamp)(10, 20, 10)).toBe(10);
      expect((0, _util.clamp)(10, 20, 20)).toBe(20);
      expect((0, _util.clamp)(20, 10, 10)).toBe(20); // special case
    });
  });
  describe('coerceArray', function () {
    test('should return an array', function () {
      expect((0, _util.coerceArray)(['a'])).toEqual(['a']);
      expect((0, _util.coerceArray)('a')).toEqual(['a']);
    });
  });
  describe('coerceFunction', function () {
    test('should return a function', function () {
      var _coerceFunction;
      expect(typeof (0, _util.coerceFunction)(function () {
        return 'function';
      })).toEqual('function');
      expect(typeof (0, _util.coerceFunction)('value')).toEqual('function');
      expect((_coerceFunction = (0, _util.coerceFunction)('value')) === null || _coerceFunction === void 0 ? void 0 : _coerceFunction()).toEqual('value');
    });
  });
  describe('extractAriaProps', function () {
    test('should extract aria-related props as a return object', function () {
      var testProps = {
        role: 'button',
        'aria-hidden': true,
        value: 'value'
      };
      var expected = {
        role: 'button',
        'aria-hidden': true
      };
      var remaining = {
        value: 'value'
      };
      var actual = (0, _util.extractAriaProps)(testProps);
      expect(actual).toMatchObject(expected);
      expect(testProps).toMatchObject(remaining);
    });
  });
  describe('isRenderable', function () {
    test('should return {true} for function', function () {
      var expected = true;
      var view = (0, _util.isRenderable)(function () {});
      expect(view).toEqual(expected);
    });
    test('should return {true} for string', function () {
      var expected = true;
      var view = (0, _util.isRenderable)('div');
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.forwardRef', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.forwardRef)(function () {}));
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.memo', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.memo)(function () {}));
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.lazy', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.lazy)(function () {}));
      expect(view).toEqual(expected);
    });
  });
  describe('memoize', function () {
    test('should memoize function', function () {
      var obj = {},
        testMethod = function testMethod(key) {
          obj[key] = (obj[key] || 0) + 1;
        },
        memoizedTest = (0, _util.memoize)(testMethod);
      expect(obj).not.toHaveProperty('a');
      memoizedTest('a');
      expect(obj).toHaveProperty('a', 1);
      memoizedTest('a');
      memoizedTest('a');
      expect(obj).toHaveProperty('a', 1);
    });
    test('should forward all args to memoized function', function () {
      var spy = jest.fn();
      var memoized = (0, _util.memoize)(spy);
      memoized(1, 2);
      var expected = [1, 2];
      var actual = spy.mock.calls[0];
      expect(expected).toEqual(actual);
    });
  });
  describe('mergeClassNameMaps', function () {
    var baseMap = {
      'class-base-only': 'real-class-base-only',
      'class-shared': 'real-class-shared-base',
      'class-shared-another': 'real-class-shared-another-base'
    };
    var additiveMap = {
      'class-shared': 'real-class-shared-additive',
      'class-shared-another': 'real-class-shared-another-additive',
      'class-additive-only': 'real-class-additive-only'
    };

    // Helper function to get an object from the proxy object that has only getters for properties to make testing easier
    var getResultFromProxy = function getResultFromProxy(proxy) {
      var keys = ['class-base-only', 'class-shared', 'class-shared-another', 'class-additive-only'];
      var obj = {};
      for (var i = 0; i < keys.length; i++) {
        if (keys[i] !== proxy[keys[i]]) {
          obj[keys[i]] = proxy[keys[i]];
        }
      }
      return obj;
    };
    test('should return a base map if an additive map is not given', function () {
      var actual = (0, _util.mergeClassNameMaps)(baseMap);
      expect(actual).toEqual(baseMap);
    });
    test('should return a merged map containing shared class names', function () {
      var expected = {
        'class-base-only': 'real-class-base-only',
        'class-shared': 'real-class-shared-base real-class-shared-additive',
        'class-shared-another': 'real-class-shared-another-base real-class-shared-another-additive'
      };
      var actual = getResultFromProxy((0, _util.mergeClassNameMaps)(baseMap, additiveMap));
      expect(actual).toEqual(expected);
    });
    test('should return a merged map containing allowed matching class names', function () {
      var expected = {
        'class-base-only': 'real-class-base-only',
        'class-shared': 'real-class-shared-base real-class-shared-additive',
        'class-shared-another': 'real-class-shared-another-base'
      };
      var actual = getResultFromProxy((0, _util.mergeClassNameMaps)(baseMap, additiveMap, ['class-shared']));
      expect(actual).toEqual(expected);
    });
  });
  describe('mapAndFilterChildren', function () {
    test('Returns null if null passed', function () {
      var expected = null;
      var actual = (0, _util.mapAndFilterChildren)(null, function (val) {
        return val;
      });
      expect(actual).toBe(expected);
    });
    test('Returns passed array if identity filter', function () {
      var children = [1, 2, 3];
      var expected = children;
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val;
      });
      expect(actual).toEqual(expected);
    });
    test('Returns passed array without nullish or false entries with identity filter', function () {
      // eslint-disable-next-line no-undefined
      var children = [1, 2, null, 3, undefined, false];
      var expected = [1, 2, 3];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val;
      });
      expect(actual).toEqual(expected);
    });
    test('Does not call filter with nullish or false entries', function () {
      var spy = jest.fn();
      // eslint-disable-next-line no-undefined
      var children = [1, 2, null, 3, undefined, false];
      (0, _util.mapAndFilterChildren)(children, spy);
      var expected = 3;
      var actual = spy.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('Returns without null entries from filter', function () {
      var children = [1, 2, 3];
      var expected = [1, 3];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val === 2 ? null : val;
      });
      expect(actual).toEqual(expected);
    });
    test('Runs custom filter', function () {
      var children = [1, 2, 3];
      var expected = [1];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val === 2 ? null : val;
      }, function (val) {
        return val === 1;
      });
      expect(actual).toEqual(expected);
    });
    test('should forward value and index to callback', function () {
      var spy = jest.fn();
      (0, _util.mapAndFilterChildren)([1], spy);
      var expected = [1,
      // value
      0 // index
      ];
      var actual = spy.mock.calls[0];
      expect(expected).toEqual(actual);
    });
  });
  describe('shallowEqual', function () {
    var child = {
      name: 'child'
    };
    test('should return `true` if the values of all keys are strictly equal', function () {
      expect((0, _util.shallowEqual)(child, child)).toBe(true);
      expect((0, _util.shallowEqual)(child, null)).toBe(false);
      var fakeChild = {
        name: 'fake'
      };
      expect((0, _util.shallowEqual)(child, fakeChild)).toBe(false);
      fakeChild.name = 'child';
      expect((0, _util.shallowEqual)(child, fakeChild)).toBe(true);
      child.toString = function () {
        child.toString.apply(child, arguments);
      };
      expect((0, _util.shallowEqual)(child, fakeChild)).toBe(false);
    });
  });
});