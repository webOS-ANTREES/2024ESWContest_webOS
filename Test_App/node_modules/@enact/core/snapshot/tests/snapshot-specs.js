"use strict";

var _snapshot = require("../snapshot");
function returnsUndefined() {}
describe('snapshot', function () {
  describe('isWindowReady', function () {
    test('should return `true` if window is ready', function () {
      var expected = true;
      var actual = (0, _snapshot.isWindowReady)();
      expect(actual).toBe(expected);
    });
    test('should return `false` if window is not ready', function () {
      var windowSpy = jest.spyOn(window, 'window', 'get').mockImplementation(returnsUndefined);
      var expected = false;
      var actual = (0, _snapshot.isWindowReady)();
      expect(actual).toBe(expected);
      windowSpy.mockRestore();
    });
  });
  describe('onWindowReady', function () {
    test('should call a given callback function immediately if window is ready', function () {
      var spy = jest.fn();
      (0, _snapshot.onWindowReady)(spy);
      expect(spy).toHaveBeenCalled();
    });
    test('should not call a given callback function if window is not ready', function () {
      var windowSpy = jest.spyOn(window, 'window', 'get').mockImplementation(returnsUndefined);
      var spy = jest.fn();
      (0, _snapshot.onWindowReady)(spy);
      expect(spy).not.toHaveBeenCalled();
      windowSpy.mockRestore();
    });
  });
  describe('windowReady', function () {
    test('should call queued callbacks if window is ready', function () {
      var windowSpy = jest.spyOn(window, 'window', 'get').mockImplementation(returnsUndefined);
      var spy = jest.fn();
      (0, _snapshot.onWindowReady)(spy);
      (0, _snapshot.onWindowReady)(spy);
      expect(spy).not.toHaveBeenCalled();
      windowSpy.mockRestore();
      (0, _snapshot.windowReady)();
      expect(spy).toHaveBeenCalledTimes(2);
    });
    test('should throw an error if window is not ready', function () {
      var consoleErrorMock = jest.spyOn(console, 'error').mockImplementation();
      var windowSpy = jest.spyOn(window, 'window', 'get').mockImplementation(returnsUndefined);
      var spy = jest.fn();
      (0, _snapshot.onWindowReady)(spy);
      expect(_snapshot.windowReady).toThrow('windowReady cannot be run until the window is available');
      expect(spy).not.toHaveBeenCalled();
      consoleErrorMock.mockRestore();
      windowSpy.mockRestore();
    });
  });
});