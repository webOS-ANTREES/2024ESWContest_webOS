"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Expandable = void 0;
var _Cancelable = _interopRequireDefault(require("@enact/ui/Cancelable"));
var _hoc = _interopRequireDefault(require("@enact/core/hoc"));
var _Toggleable = _interopRequireDefault(require("@enact/ui/Toggleable"));
var _UiRadioDecorator = _interopRequireDefault(require("../UiRadioDecorator"));
var _ExpandableSpotlightDecorator = _interopRequireDefault(require("./ExpandableSpotlightDecorator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
// TODO: This module may not doc correctly but we'll need to wait until our doc parsing script is
// ready

/**
 * Called by {@link ui/Cancelable.Cancelable} when a cancel event occurs and calls the
 * `onClose` handler provided by the wrapping Toggleable HOC.
 *
 * @param  {Object} props Current props object
 *
 * @returns {undefined}
 * @private
 */
var handleCancel = function handleCancel(ev, props) {
  if (props.open) {
    props.onClose();
    ev.stopPropagation();
  }
};

/**
 * Default config for {@link moonstone/ExpandableItem.Expandable}.
 *
 * @memberof moonstone/ExpandableItem.Expandable
 * @hocconfig
 */
var defaultConfig = {
  /**
   * Returns the child -- either a node or a CSS selector -- to focus after expanding.
   *
   * If this function is defined, it will be passed the container node and the current set of
   * props and should return either a node or a CSS selector to be passed to
   * {@link spotlight/Spotlight.focus}.
   *
   * @type {Function}
   * @default null
   * @memberof moonstone/ExpandableItem.Expandable.defaultConfig
   * @private
   */
  getChildFocusTarget: null,
  /**
   * When `true` and used in conjunction with `noAutoFocus` when `false`, the contents of the
   * container will receive spotlight focus expanded, even in pointer mode.
   *
   * @type {Boolean}
   * @default false
   * @memberof moonstone/ExpandableItem.Expandable.defaultConfig
   * @public
   */
  noPointerMode: false
};

/**
 * A higher-order component that manages the open state of a component and adds {@link ui/Cancelable.Cancelable}
 * support to call the `onClose` handler on
 * cancel.
 *
 * @class Expandable
 * @memberof moonstone/ExpandableItem
 * @mixes ui/Toggleable.Toggleable
 * @mixes moonstone/UiRadioDecorator.RadioDecorator
 * @mixes ui/Cancelable.Cancelable
 * @hoc
 * @public
 */
var Expandable = exports.Expandable = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  return (0, _Toggleable["default"])({
    toggle: null,
    activate: 'onOpen',
    deactivate: 'onClose',
    prop: 'open'
  }, (0, _UiRadioDecorator["default"])({
    activate: 'onOpen',
    deactivate: 'onClose',
    prop: 'open'
  }, (0, _Cancelable["default"])({
    component: 'span',
    onCancel: handleCancel
  }, (0, _ExpandableSpotlightDecorator["default"])({
    noPointerMode: config.noPointerMode,
    getChildFocusTarget: config.getChildFocusTarget
  }, Wrapped))));
});
var _default = exports["default"] = Expandable;