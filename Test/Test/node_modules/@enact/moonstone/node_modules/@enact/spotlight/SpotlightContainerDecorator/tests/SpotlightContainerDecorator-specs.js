"use strict";

require("@testing-library/jest-dom");
var _react = require("@testing-library/react");
var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));
var _SpotlightContainerDecorator = _interopRequireDefault(require("../SpotlightContainerDecorator"));
var _pointer = require("../../src/pointer");
var _spotlight = _interopRequireDefault(require("../../src/spotlight"));
var _ElementPrototype = _interopRequireDefault(require("./Element.prototype.closest"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var testId = 'test-spotlightContainerDecorator';
describe('SpotlightContainerDecorator', function () {
  var hoverPosition = {
    clientX: 0,
    clientY: 1
  };
  var unhoverPosition = {
    clientX: 0,
    clientY: 0
  };
  var Div = function Div(props) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread({}, props));
  };
  (0, _ElementPrototype["default"])(beforeAll, afterAll);
  beforeEach(function () {
    _spotlight["default"].setActiveContainer(null);
    (0, _pointer.updatePointerPosition)(0, 0);
  });
  test('should set itself as the active container on mouse enter', /*#__PURE__*/_asyncToGenerator(function* () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var user = _userEvent["default"].setup();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      "data-testid": testId,
      spotlightId: "test-container"
    }));
    var component = _react.screen.getByTestId(testId);
    yield user.pointer({
      target: component,
      coords: hoverPosition
    });
    var expected = 'test-container';
    var actual = _spotlight["default"].getActiveContainer();
    expect(actual).toBe(expected);
  }));
  test('should set active container to parent container on mouse leave', /*#__PURE__*/_asyncToGenerator(function* () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    var user = _userEvent["default"].setup();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      spotlightId: "outer-container",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        "data-testid": testId,
        spotlightId: "inner-container"
      })
    }), {
      attachTo: node
    });
    var component = _react.screen.getByTestId(testId);

    // set inner-container as active
    yield user.pointer({
      target: component,
      coords: hoverPosition
    });
    (0, _pointer.updatePointerPosition)(0, 1);

    // leave inner-container
    yield user.pointer({
      target: component.parentNode,
      coords: unhoverPosition
    });
    var expected = 'outer-container';
    var actual = _spotlight["default"].getActiveContainer();
    expect(actual).toBe(expected);
  }));
  test('should not set active container on mouse leave if another container is active', /*#__PURE__*/_asyncToGenerator(function* () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    var user = _userEvent["default"].setup();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsxs)(Component, {
      spotlightId: "outer-container",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        "data-testid": testId,
        spotlightId: "inner-container"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        spotlightId: "self-only-container"
      })]
    }), {
      attachTo: node
    });
    var component = _react.screen.getByTestId(testId);

    // set inner-container as active
    yield user.pointer({
      target: component,
      coords: hoverPosition
    });
    (0, _pointer.updatePointerPosition)(0, 1);

    // set another container to be active
    _spotlight["default"].setActiveContainer('self-only-container');

    // leave inner-container
    yield user.unhover(component);
    var expected = 'self-only-container';
    var actual = _spotlight["default"].getActiveContainer();
    expect(actual).toBe(expected);
  }));
  test('should forward onFocusCapture events', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref4) {
      var onFocusCapture = _ref4.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onFocusCapture: spy
    }));
    focus({});
    var expected = 1;
    expect(spy).toHaveBeenCalledTimes(expected);
  });
  test('should suppress onFocusCapture events when spotlightDisabled', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref5) {
      var onFocusCapture = _ref5.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onFocusCapture: spy,
      spotlightDisabled: true
    }));

    // building out the api called on the event object + target
    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return true;
        }
      }
    });
    expect(spy).not.toHaveBeenCalled();
  });
  test('should forward onBlurCapture events', function () {
    var spy = jest.fn();
    var _blur;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref6) {
      var onBlurCapture = _ref6.onBlurCapture;
      _blur = onBlurCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    }));

    // building out the api called on the event object + target
    _blur({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return _blur({});
        }
      }
    });
    var expected = 1;
    expect(spy).toHaveBeenCalledTimes(expected);
  });
  test('should suppress onBlurCapture events when focus was suppressed', function () {
    var spy = jest.fn();
    var _blur2;
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref7) {
      var onBlurCapture = _ref7.onBlurCapture,
        onFocusCapture = _ref7.onFocusCapture;
      _blur2 = onBlurCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    }));

    // building out the api called on the event object + target
    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        // the focus handler calls blur() on the target so we're simulating that here by
        // wiring our onBlurCapture handler directly to the invocation. This isn't a
        // perfect modeling of the system but serves to validate the callback
        // suppression logic.
        blur: function blur() {
          return _blur2({});
        }
      }
    });
    expect(spy).not.toHaveBeenCalled();
  });
});